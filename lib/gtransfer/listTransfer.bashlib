#!/bin/bash
#  listTransfer.bashlib - library functions for transferring lists

:<<COPYRIGHT

Copyright (C) 2012, 2013 Frank Scheiner
Copyright (C) 2015, 2016 Frank Scheiner, HLRS, Universitaet Stuttgart

The program is distributed under the terms of the GNU General Public License

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

COPYRIGHT

################################################################################
#  DEFINES
################################################################################

readonly _listTransfer_Version="0.7.0"

################################################################################
#  INCLUDES
################################################################################

:<<INCLUDE
exitCodes.bashlib
helperFunctions.bashlib
INCLUDE

#  only source if not already sourced
if [[ -z "$_exitCodes_Version" ]]; then
	. "$_LIB"/${_gtransfer_libraryPrefix}/exitCodes.bashlib
fi

if [[ -z "$_helperFunctions_Version" ]]; then
	. "$_LIB"/${_gtransfer_libraryPrefix}/helperFunctions.bashlib
fi

################################################################################
#  VARIABLES
################################################################################

if [[ ! "$__GLOBAL__gtTmpSuffix" ]]; then
	readonly __GLOBAL__gtTmpSuffix="#gt#tmp#"
fi
if [[ ! "$__GLOBAL__gtCacheSuffix" ]]; then
	readonly __GLOBAL__gtCacheSuffix="#gt#cache#"
fi

verboseExec=1

################################################################################
#  FUNCTIONS
################################################################################

:<<FUNCTIONS
listTransfer/sortTransferList
listTransfer/transferData
listTransfer/doTransferStep
listTransfer/createTgftpTransferCommand
listTransfer/createTransferList
listTransfer/getDestinationFromTransferList
listTransfer/getSourceFromTransferList
listTransfer/getTransferIdForTransferList
listTransfer/getTransferSizeFromTransferList
FUNCTIONS

#  sortTransferList() - sort transfer list by size and print the file name of
#+ the sorted list
#+ @transferList: (unsorted) transfer list (file name)
#+ @sortMode:     "min-to-max" or "max-to-min"
listTransfer/sortTransferList()
{
	local _transferList="$1"
	local _sortMode="$2"
	
	#  A line in a transfer list looks like that:
	#													 offset
	#  source					      destination					 |    size, modify timestamp and permissions
	#  |						      |						         |    |
	#  "ftp://vserver1.asc:2811/~/files/test4/file.00355" "ftp://vserver2.asc:2811/~/files/test4/file.00355" 0,-1 size=0;modify=1328981550;mode=0644;

	local _sortedTransferList="${__GLOBAL__gtTmpDir}/$$_transferList_sorted.${__GLOBAL__gtTmpSuffix}"
	
	if [[ "$_sortMode" == "min-to-max" ]]; then
		#  strip comment lines
		grep -v '^#' "$_transferList" | sort -n -t ' ' -k 4.6 > "$_sortedTransferList"
		echo "$_sortedTransferList"
		return 0
	elif [[ "$_sortMode" == "max-to-min" ]]; then
		#  strip comment lines
		grep -v '^#' "$_transferList" | sort -r -n -t ' ' -k 4.6 > "$_sortedTransferList"
		echo "$_sortedTransferList"
		return 0
	else
		return 1
	fi
}


#  dpathAvailable() - determine if a dpath is available
#+ @source:      The source URL (e.g.
#+               "gsiftp://user@host.domain:2811/path/to/files")
#+ @destination: The destination URL (similar to source URL)
#
#  Just determines if a dpath for the given source and destination URLs is
#+ available (prints out the path of the dpath and returns 0) or not (returns
#+ 1).
listTransfer/dpathAvailable()
{
	local _source="$1"
	local _destination="$2"
	
	local _sourceWithoutPath=$( helperFunctions/getURLWithoutPath "$_source" )
	local _destinationWithoutPath=$( helperFunctions/getURLWithoutPath "$_destination" )
	
	#  get corresponding dpath name (and remove any "username@" portions in
	#+ the URL before hashing).
	local _dpathFilename=$( helperFunctions/hashSourceDestination $( echo $_sourceWithoutPath | sed -e 's/:\/\/.*@/:\/\//' ) $( echo $_destinationWithoutPath | sed -e 's/:\/\/.*@/:\/\//' ) )

	if [[ -e "$gtransferDataPathDirectory/$_dpathFilename" ]]; then
		echo "$gtransferDataPathDirectory/$_dpathFilename"
		return 0
	elif [[ -e "$gtransferSystemDataPathDirectory/$_dpathFilename" ]]; then
		echo "$gtransferSystemDataPathDirectory/$_dpathFilename"
		return 0
	else
		return 1
	fi
}


# Return the dpath file name that corresponds to the given source and
# destination URLs.
#
# $1 (_source)      - The source URL (e.g.
#                     "gsiftp://user@host.domain:2811/path/to/files")
# $2 (_destination) - The destination URL (similar to source URL)
#
# Returns the file name and path of the corresponding dpath if it is available.
# If it is not available, it creates a temporary dpath in gt's temp dir for the
# current transfer and returns its name and path.
listTransfer/getDpathFile()
{
	local _source="$1"
	local _destination="$2"

	local _dpathFile=""

	_dpathFile=$( listTransfer/dpathAvailable "$_source" "$_destination" )

	# If no pre-created dpath is available, create a temporary one.
	if [[ $? -ne 0 ]]; then

		local _sourceWithoutPath=$( helperFunctions/getURLWithoutPath "$_source" )
		local _destinationWithoutPath=$( helperFunctions/getURLWithoutPath "$_destination" )

		local _dpathFilename=$( helperFunctions/hashSourceDestination $( echo $_sourceWithoutPath | sed -e 's/:\/\/.*@/:\/\//' ) $( echo $_destinationWithoutPath | sed -e 's/:\/\/.*@/:\/\//' ) )

		_dpathFile="${__GLOBAL__gtTmpDir}/$_dpathFilename"

		# Set bandwidth to 10 Gb, even if we don't know, which bandwidth the
		# connection really provides. This is ok, because when multiple differing
		# metrics are selected by a user, we cannot continue either, because the
		# temp path only provides one metric. In a case where a user selects metric 0
		# multiple times (e.g. to get a sort of striping), this works fine because
		# the bandwidth proportions are then always 1 to 1 ( to 1 [...]). Would be
		# the same for a dpath with multiple metrics.
		cat > "$_dpathFile" <<-EOF
		<source>
		$_sourceWithoutPath
		</source>
		<destination>
		$_destinationWithoutPath
		</destination>
		<path metric="0" bandwidth="10Gb">
		$_sourceWithoutPath;$_destinationWithoutPath
		</path>
		EOF
	fi

	echo "$_dpathFile"

	return
}


#  getDpathData() - get dpath data with one line per transfer step
#+ @source:      The source URL (e.g.
#+               "gsiftp://user@host.domain:2811/path/to/files")
#+ @destination: The destination URL (similar to source URL)
#+ @metric:      The metric value to select the path
#
#  Returns dpath data if dpath is available and returns dpath data for a single
#+ step transfer if no dpath is available.
listTransfer/getDpathData()
{
	local _source="$1"
	local _destination="$2"
	
	local _metric="$3"

	local _sourceWithoutPath=$( helperFunctions/getURLWithoutPath "$_source" )
	local _destinationWithoutPath=$( helperFunctions/getURLWithoutPath "$_destination" )

	#  NOTICE:
	#+ The following two lines *are* needed! This is because if done with
	#+ one line e.g. "local _dapthFile=$([...])", the return value is "0"
	#+ despite the fact that no dpath is available (it should be "1" then!).
	local _dpathfile
	_dpathFile=$( listTransfer/dpathAvailable "$_source" "$_destination" )
	
	local _functionReturnValue=$?

	if [[ $_functionReturnValue -eq 0 ]]; then
	
		#helperFunctions/echoIfVerbose -e "Dpath used:\n$_dPathFile"
		
		local -a _dpathArray=( $( helperFunctions/xtractXMLAttributeValue "path .*metric=\"$_metric\"" $_dpathFile ) )
		
		echo ${_dpathArray[@]}
		
		return 0
		
	elif [[ $_functionReturnValue -eq 1 ]]; then
	
		#helperFunctions/echoIfVerbose -e "No dpath available. Performing direct transfer."
	
		local -a _dpathArray[0]="$_sourceWithoutPath;$_destinationWithoutPath"
		
		echo ${_dpathArray[@]}
		
		return 0
	else	
		return 1
	fi
}


#  getTransferParameters() - get transfer parameters with one line per transfer
#+ step
#+ @dpathArray: Dpath data with one field per step (= output of
#+              listTransfer/getDpathData())
#+
#+ @CALL:       getTransferParameters "${_dpathArray[*]}"
#
#  Ouput depends on the number of transfer steps. Hence the dpath data must have
#+ been determined prior to the parameters.
#
#  NOTE: Spaces in the parameters are exchanged by '#'.
listTransfer/getTransferParameters()
{
	local -a _dpathArray=($1)

	for _sourceDestination in ${_dpathArray[@]}; do
		
		local _source="${_sourceDestination%%;*}"
		local _destination="${_sourceDestination##*;}"
		
		local _dparamFile
		_dparamFile=$( listTransfer/dparamAvailable "$_source" "$_destination" )

		if [[ -e "$_dparamFile" && \
		      -z "$gsiftpUserParams" \
		]]; then
			#  default params file available, no user params
			#+ specified
			_unescapedTransferParameters=$( helperFunctions/xtractXMLAttributeValue "gsiftp_params" $_dparamFile )

		elif [[ -e "$_dparamFile" && \
			-n "$gsiftpUserParams" \
		]]; then
		        #  user params specified
			_unescapedTransferParameters=$( helperFunctions/xtractXMLAttributeValue "gsiftp_params" $_dparamFile )

		        #  if user only provided "-len|-partial-length [...]", then just add it to the default gsiftp params,
		        #+ if not only use the user provided params.
			grepMatch=$( echo "$gsiftpUserParams" | egrep -o "\-len [[:alnum:]]*|\-partial-length [[:alnum:]]*" )
			if [[ "$grepMatch" == "$gsiftpUserParams" ]]; then
				_unescapedTransferParameters="$_unescapedTransferParameters $gsiftpUserParams"
			else
				_unescapedTransferParameters="$gsiftpUserParams"
			fi

		elif [[ -n "$gsiftpUserParams" ]]; then
			#  no default params available, use parameters
			#+ supplied by user or a combination of builtin
			#+ parameters and "-len"
			grepMatch=$( echo "$gsiftpUserParams" | egrep -o "\-len [[:alnum:]]*|\-partial-length [[:alnum:]]*" )
			if [[ "$grepMatch" == "$gsiftpUserParams" ]]; then
				_unescapedTransferParameters="$gsiftpDefaultParams $gsiftpUserParams"
			else
				_unescapedTransferParameters="$gsiftpUserParams"
			fi

		else
			#  no default params available, use builtin
			#+ default parameters
			_unescapedTransferParameters="$gsiftpDefaultParams"
		fi
		
		#local _functionReturnValue=$?
		#	
		#if [[ $_functionReturnValue -eq 0 ]]; then
		#	_unescapedTransferParameters=$( helperFunctions/xtractXMLAttributeValue "gsiftp_params" $_dparamFile )
		#	echo "${_unescapedTransferParameters// /#}"
		#else
		#	#  if no dparam available use builtin defaults (for now!)
		#	echo "${gsiftpDefaultParams// /#}"
		#fi

		#  escape transfer parameters with "#".
		echo "${_unescapedTransferParameters// /#}"
	done

	return
}


#  performTransfer() - transfer given list of files
#+ @transferList:     (possibly unsorted) transfer list (file name)
#+ @metric:           the metric to use to choose a path
#+ @tgftpLogFileName: file name for tgftp log
listTransfer/performTransfer()
{
	local _transferList="$1"
	local _metric="$2"
	local _tgftpLogFileName="$3"

	if [[ -s "$_transferList" ]]; then
	
		#  usage:
		#+ transferData transferList \
		#+              metric \
		#+              tmpLogfileName \
		#+              dpathArray \
		#+              dparamsArray
	
		local _transferListSource=$( listTransfer/getSourceFromTransferList "$_transferList" )
		local _transferListDestination=$( listTransfer/getDestinationFromTransferList "$_transferList" )

		local sourcePath=$( helperFunctions/getPathFromURL "$_transferListSource" )
		local destinationPath=$( helperFunctions/getPathFromURL "$_transferListDestination" )

		local sourceFile=$( helperFunctions/getFilenameFromURL "$_transferListSource" )
		local destinationFile=$( helperFunctions/getFilenameFromURL "$_transferListDestination" )

		local memToMem=1

		#  is this a memory to memory transfer?
		if [[ "${sourcePath}${sourceFile}" == "/dev/zero" && \
		      "${destinationPath}${destinationFile}" == "/dev/null" \
		]]; then
			memToMem=0
		fi

		#echo "DEBUG: listTransfer/dpathAvailable $_transferListSource $_transferListDestination" 1>&2

		local _dpathFile=$( listTransfer/dpathAvailable "$_transferListSource" "$_transferListDestination" )

		#echo "DEBUG: _dpathFile=\"$_dpathFile\"" 1>&2

		if [[ -e "$_dpathFile" && \
		      $memToMem != 0 \
		]]; then
			helperFunctions/echoIfVerbose ""
			helperFunctions/echoIfVerbose -e "${_program} [${gtInstance}]: Data path used:\n$_dpathFile"
		fi
		
		#  get dpath array
		local -a _dpathArray=( $( listTransfer/getDpathData "$_transferListSource" "$_transferListDestination" "$_metric" ) )

		#echo "DEBUG: listTransfer/dparamAvailable $_transferListSource $_transferListDestination" 1>&2

		#local _dparamFile=$( listTransfer/dparamAvailable "$_transferListSource" "$_transferListDestination" )

		#echo "DEBUG: _dparamFile=\"$_dparamFile\"" 1>&2

		#if [[ -e "$_dparamFile" && \
		#      $memToMem != 0 \
		#]]; then
		#	helperFunctions/echoIfVerbose -e "Default params used:\n$_dparamFile"
		#fi
	
		#  get dparams array
		local -a _dparamsArray=( $( listTransfer/getTransferParameters "${_dpathArray[*]}" ) )
	
		#echo "DEBUG: ${_dpathArray[0]}"
		#echo "DEBUG: ${_dpathArray[1]}"
	
		#echo "DEBUG: ----"
	
		#echo "DEBUG: ${_dparamsArray[0]}"
		#echo "DEBUG: ${_dparamsArray[1]}"
	
		#return
		listTransfer/transferData "$_transferList" \
			                  "$_metric" \
			                  "$_tgftpLogFileName" \
			                  "${_dpathArray[*]}" \
			                  "${_dparamsArray[*]}"
			                  
		_functionReturnValue="$?"
		
		if [[ $_functionReturnValue -eq $_gtransfer_exit_ok ]]; then
			#  TODO:
			#  Move temp file removal to onExit() function. Exclude
			#+ files that should survive a restart of gtransfer!
			
			#  if the whole transfer succeeded,
			#  reactivate filename globbing for temp file deletion
			set +f
			#  ...remove temporary files
			#  file with name of transit site temporary dir
			rm -f "${__GLOBAL__gtTmpDir}/$_transferId".transitSiteTempDir &>/dev/null
			#  any finished transfer step markers
			rm -f "${__GLOBAL__gtTmpDir}/"*.finished &>/dev/null
			#  temporary file(s) containing the running tgftp transfer command(s)
			#+ and its output.
			rm -f "${__GLOBAL__gtTmpDir}/"*."$tgftpTransferCommand"* &>/dev/null
			#  temporary transfer lists
			rm -f "${__GLOBAL__gtTmpDir}/"*.transferList &>/dev/null

			helperFunctions/echoIfVerbose ""
			helperFunctions/echoIfVerbose -e "${_program} [${gtInstance}]: The transfer succeeded!"
	
			if [[ $gtProgressIndicatorSet != 0 ]]; then
				echo ""
			fi
			
		fi

	fi

	return
		
}




#  dparamAvailable() - determine if a dparam is available
#+ @source:      The source URL (e.g.
#+               "gsiftp://user@host.domain:2811/path/to/files")
#+ @destination: The destination URL (similar to source URL)
#
#  Just determines if a dparam for the given source and destination URLs is
#+ available (prints out the path of the dparam and returns 0) or not (returns
#+ 1).
listTransfer/dparamAvailable()
{
	local _source="$1"
	local _destination="$2"
	
	local _sourceWithoutPath=$( helperFunctions/getURLWithoutPath "$_source" )
	local _destinationWithoutPath=$( helperFunctions/getURLWithoutPath "$_destination" )
	
	#  get corresponding dparam name (and remove any "username@" portions in
	#+ the URL before hashing).
	local _dparamFilename=$( helperFunctions/hashSourceDestination $( echo $_sourceWithoutPath | sed -e 's/:\/\/.*@/:\/\//' ) $( echo $_destinationWithoutPath | sed -e 's/:\/\/.*@/:\/\//' ) )
	
	if [[ -e "$gtransferDefaultParamsDirectory/$_dparamFilename" ]]; then
		echo "$gtransferDefaultParamsDirectory/$_dparamFilename"
		return 0
	elif [[ -e "$gtransferSystemDefaultParamsDirectory/$_dparamFilename" ]]; then
		echo "$gtransferSystemDefaultParamsDirectory/$_dparamFilename"
		return 0
	else
		return 1
	fi
}





listTransfer/transferData()
{
	#  transfers data from source to target
	#
	#  usage:
	#+ transferData transferList \
	#+              metric \
	#+              tmpLogfileName \
	#+              dpathArray \
	#+              dparamsArray
	
	#  TODO:
	#  Add argument to enable processing of single specific transfer steps.
	#+ E.g.: transferStep: all - all steps, 1 - step 1, etc.
	
	#set -f

	local _transferList="$1"
	
	if [[ ! -s "$_transferList" ]]; then
		return 1
	fi
	
	local dataPathMetric="$2"
	local tgftpTempLogfileName="$3"
	
	local -a _dpathArray=($4)
	local -a _dparamsArray=($5)

	#echo ${_dpathArray[0]}
	#echo ${_dpathArray[1]}
	
	#echo "----"
	
	#echo ${_dparamsArray[0]}
	#echo ${_dparamsArray[1]}
	#return 0

	local tgftpLogfileName=""

	#  max number of retries gtransfer will do
	local maxRetries="${GT_MAX_RETRIES:-$gtMaxRetries}"
	local retries=0

	#  get source and destination URLs from transfer list
	#
	#  NOTICE:
	#+ All URLs contained in a transfer list need to have the same source
	#+ and destination hosts!
	local source=$( listTransfer/getSourceFromTransferList "$_transferList" )
	local destination=$( listTransfer/getDestinationFromTransferList "$_transferList" )
	#  for future functionality
	#local transferSize=$( listTransfer/getTransferSizeFromTransferList "$_transferList" )

	local sourceWithoutPath=$( helperFunctions/getURLWithoutPath "$source" )
	local destinationWithoutPath=$( helperFunctions/getURLWithoutPath "$destination" )

	#  not useful for a transfer list
	local sourcePath=$( helperFunctions/getPathFromURL "$source" )
	local destinationPath=$( helperFunctions/getPathFromURL "$destination" )

	local sourceFile=$( helperFunctions/getFilenameFromURL "$source" )
	local destinationFile=$( helperFunctions/getFilenameFromURL "$destination" )
	#  ^

	local sourceUsernamePortion=$( echo $sourceWithoutPath | grep -o "://.*@" | sed -e 's/:\/\///' )
	local destinationUsernamePortion=$( echo $destinationWithoutPath | grep -o "://.*@" | sed -e 's/:\/\///' )

	#echo "($$) DEBUG: source=\"$source\""
	#echo "($$) DEBUG: destination=\"$destination\""
	#echo "($$) DEBUG: sourceWithoutPath=\"$sourceWithoutPath\""
	#echo "($$) DEBUG: destinationWithoutPath=\"$destinationWithoutPath\""
	#echo "($$) DEBUG: sourcePath=\"$sourcePath\""
	#echo "($$) DEBUG: destinationPath=\"$destinationPath\""
	#echo "($$) DEBUG: sourceFile=\"$sourceFile\""
	#echo "($$) DEBUG: destinationFile=\"$destinationFile\""
	#echo "($$) DEBUG: sourceUsernamePortion=\"$sourceUsernamePortion\""
	#echo "($$) DEBUG: destinationUsernamePortion=\"$destinationUsernamePortion\""
	#exit 1

        #echo "($$) DEBUG: retries=\"$retries\" maxRetries=\"$maxRetries\""
	#exit

	local transferStepNumber=0
	local maxTransferStepNumber=${#_dpathArray[@]}

	local _transferId=$( listTransfer/getTransferIdForTransferList "$_transferList" )
	local _transitSiteTempDir=$( helperFunctions/getTransitSiteTempDir "$_transferId" )

	while [[ 1 ]]; do

		if [[ $transferStepNumber -ge $maxTransferStepNumber ]]; then
			break
		fi

		local transferStep=${_dpathArray[$transferStepNumber]}

	       	#  source and destination for transfer step
	       	local transferStepSource=${transferStep%%;*}
	    	local transferStepDestination=${transferStep##*;}

		local _escapedTransferParameters=""	    	
	    	local _transferParameters=""
	    	
	    	#  if the dparamsArray contains only one element (=simple
	    	#+ string), then use these parameters for all steps
	    	if [[ ${#_dparamsArray[*]} -eq 1 ]]; then
	    		_escapedTransferParameters=${_dparamsArray[0]}
	    	else
	    		_escapedTransferParameters=${_dparamsArray[$transferStepNumber]}
		fi

		#  the "#" must be escaped (at least for bash 3.1.17(1)). The
		#+ escaped "#" also works with newer bash versions.
    		_transferParameters="${_escapedTransferParameters//\#/ }"
		#echo "($$) DEBUG: transferStepSource=\"$transferStepSource\""
		#echo "($$) DEBUG: transferStepDestination=\"$transferStepDestination\""
		#exit 1

		#  if the current transfer step is/was already finished, skip it.
		#if [[ -e "$transferId.finished" ]]; then
		#	echoIfVerbose "Transfer step: $transferStepNumber"
		#	echoIfVerbose "Skipped because already finished!"
		#	transferStepNumber=$(( $transferStepNumber + 1 ))
		#	continue
		#else
		helperFunctions/echoIfVerbose -e "\n${_program} [${gtInstance}]: Transfer step: $transferStepNumber"
		listTransfer/doTransferStep "$transferStepSource" \
					    "$transferStepDestination" \
					    "$transferStepNumber" \
					    "$_transitSiteTempDir" \
					    "$sourcePath" \
					    "$destinationPath" \
					    ${sourceFile:=NULL} \
					    ${destinationFile:=NULL} \
					    ${sourceUsernamePortion:=NULL} \
					    ${destinationUsernamePortion:=NULL} \
					    "$_transferId" \
					    "$_transferList" \
					    "$_transferParameters"
		#fi

		local RETURN="$?"

		# Did the current transfer step work?
		if [[ $RETURN -eq 130 ]]; then

			# no, it was interrupted
			kill -SIGINT $$

		elif [[ $RETURN -eq 4 ]]; then

			# yes, it was already finished in the past, so can be skipped
			helperFunctions/echoIfVerbose -e "\n${_program} [${gtInstance}]: Transfer step $transferStepNumber skipped because already finished!"
			transferStepNumber=$(( $transferStepNumber + 1 ))
			continue

		elif [[ $RETURN -eq 2 ]]; then

			# no, it failed, but can be retried later (e.g. hosts couldn't be reached)
			helperFunctions/echoIfVerbose -e "\n${_program} [${gtInstance}]: Transfer step #$transferStepNumber failed!"
			exit $_gtransfer_exit_tempfail

		elif [[ $RETURN -ne 0 && $retries -lt $maxRetries ]]; then

			# no, but can be retried instantly
			retries=$(( $retries + 1 ))
			helperFunctions/echoIfVerbose -e "\n${_program} [${gtInstance}]: Transfer step #$transferStepNumber failed! Retrying!"
			continue

		elif [[ $RETURN -eq 0 ]]; then

			# yes
			# reset retries value
			retries="0"
			#touch "${_transferId}.step_${transferStepNumber}.finished"
			transferStepNumber=$(( $transferStepNumber + 1 ))

		elif [[ "$retries" -eq "$maxRetries" ]]; then

			# max number of retries reached, try again later
			echo -e "\n${_program} [${gtInstance}]: Transfer step #$transferStepNumber failed after $retries retries! Exiting." 1>&2
			exit $_gtransfer_exit_tempfail

		fi

	done
	
	return $_gtransfer_exit_ok
}


listTransfer/doTransferStep()
{
	#  performs the actual transfer step
	#
	#  usage:
	#+ listTransfer/doTransferStep transferStepSource\
	#+			     transferStepDestination \
	#+			     transferStepNumber \
	#+			     transitSiteTempDir \
	#+			     sourcePath \
	#+			     destinationPath \
	#+			     sourceFile \
	#+			     destinationFile \
	#+			     sourceUsernamePortion \
	#+			     destinationUsernamePortion \
	#+			     transferId \
	#+			     transferList \
	#+			     transferParameters

	local transferStepSource="$1"
	local transferStepDestination="$2"
	local transferStepNumber="$3"

	local transitSiteTempDir="$4"

	local sourcePath="$5"
	local destinationPath="$6"

	local sourceFile="$7"
	if [[ "$sourceFile" == "NULL" ]]; then
		sourceFile=""
	fi
	local destinationFile="$8"
	if [[ "$destinationFile" == "NULL" ]]; then
		destinationFile=""
	fi

	local sourceUsernamePortion="$9"
	if [[ "$sourceUsernamePortion" == "NULL" ]]; then
		sourceUsernamePortion=""
	fi
	
	local destinationUsernamePortion="${10}"
	if [[ "$destinationUsernamePortion" == "NULL" ]]; then
		destinationUsernamePortion=""
	fi

	local transferId="${11}"

	local transferList="${12}"
	
	local transferParameters="${13}"

	#echo "----"
	#echo "($$) DEBUG: transferStepSource=\"$transferStepSource\""
	#echo "($$) DEBUG: transferStepDestination=\"$transferStepDestination\""
	#echo "($$) DEBUG: transferStepNumber=\"$transferStepNumber\""
	#echo "($$) DEBUG: transitSiteTempDir=\"$transitSiteTempDir\""
	#echo "($$) DEBUG: sourcePath=\"$sourcePath\""
	#echo "($$) DEBUG: destinationPath=\"$destinationPath\""
	#echo "($$) DEBUG: sourceFile=\"$sourceFile\""
	#echo "($$) DEBUG: destinationFile=\"$destinationFile\""
	#echo "($$) DEBUG: sourceUsernamePortion=\"$sourceUsernamePortion\""
	#echo "($$) DEBUG: destinationUsernamePortion=\"$destinationUsernamePortion\""
	#echo "($$) DEBUG: transferId=\"$transferId\""
	#echo "($$) DEBUG: transferList=\"$transferList\""
	#echo "($$) DEBUG: transferParameters=\"$transferParameters\""
	#echo "----"
	#return 0

	local transferStepSourceWithoutPath=$( helperFunctions/getURLWithoutPath "$transferStepSource" )
	local transferStepDestinationWithoutPath=$( helperFunctions/getURLWithoutPath "$transferStepDestination" )

	#  check if connection to source and destination is possible
	if [[ ! -z $__GLOBAL__checkConnection && \
	           $__GLOBAL__checkConnection -eq 0 \
	]]; then
		#  skip connection check
		:
	else
		if ! helperFunctions/checkConnection "$transferStepSourceWithoutPath" && \
		   ! helperFunctions/checkConnection "$transferStepDestinationWithoutPath"; then
			echo -e "\n${_program} [${gtInstance}]: Cannot connect to neither \"$transferStepSourceWithoutPath\" nor \"$transferStepDestinationWithoutPath\"! Either try again or correct your input!" 1>&2
			#  we assume that source and destination strings are correct,
			#+ and they're just unavailable currently. If the user just used
			#+ a nonexistent host, he can detect this by reading the error
			#+ message
			return 2
		elif ! helperFunctions/checkConnection "$transferStepSourceWithoutPath"; then
			echo -e "\n${_program} [${gtInstance}]: Cannot connect to \"$transferStepSourceWithoutPath\"! Either try again or correct your input!" 1>&2
			#  same as above
			return 2
		elif ! helperFunctions/checkConnection "$transferStepDestinationWithoutPath"; then
			echo -e "\n${_program} [${gtInstance}]: Cannot connect to \"$transferStepDestinationWithoutPath\"! Either try again or correct your input!" 1>&2
			#  same as above
			return 2
		fi
	fi

	#  (0) construct names for logfile and dumpfile
	########################################################################
	local tgftpLogfileName="${tgftpTempLogfileName/%.log/__step_${transferStepNumber}.log}"

	
	transferStepDefaultParams="$transferParameters"
	

	#  TODO:
	#  build temp transfer list by exchanging source and
	#+ destination.

	#  make temporary copy from the orginal transfer list
	local _tempTransferList=$( mktemp -p "${__GLOBAL__gtTmpDir}/" transferList.XXXXX )
	cp "$transferList" "$_tempTransferList" || return 3

	local _source=$( listTransfer/getSourceFromTransferList "$transferList" )
	local _destination=$( listTransfer/getDestinationFromTransferList "$transferList" )	      

	local _sourceWithoutPath=$( helperFunctions/getURLWithoutPath "$source" )
	local _destinationWithoutPath=$( helperFunctions/getURLWithoutPath "$destination" )

	local _sourcePath=$( helperFunctions/getPathFromURL "$_source" )
	local _destinationPath=$( helperFunctions/getPathFromURL "$_destination" )
	
	#  (3) transfer data (various steps possible!)
	########################################################################
	#  direct transfer
	if [[ "$transferStepSource" == "$( helperFunctions/getURLWithoutPath $transferStepSource )" && \
      	      "$transferStepDestination" == "$( helperFunctions/getURLWithoutPath $transferStepDestination )" \
	]]; then
		#  handle usernames in URLs
		transferStepSourceProtoSpec=$( helperFunctions/getProtocolSpecifier $transferStepSource )
		transferStepDestinationProtoSpec=$( helperFunctions/getProtocolSpecifier $transferStepDestination )
		#  replace protocol spec with proto. spec and username (don't forget "@" at the end)
		#  NOTICE:
		#+ Please be aware of the fact, that the shell expands the variables in the sed scripts before actually running the sed scripts.
		#+ As the proto. spec contains "/"es. they must be either escaped (hard!) or one just changes the "/"es of the "s///" command to
		#+ "|"s, as done in the following.
		if [[ "${sourceUsernamePortion}" != "" ]]; then
			transferStepSource=$( echo $transferStepSource | sed -e "s|${transferStepSourceProtoSpec}|${transferStepSourceProtoSpec}${sourceUsernamePortion}|" )
		fi
		if [[ "${destinationUsernamePortion}" != "" ]]; then
			transferStepDestination=$( echo $transferStepDestination | sed -e "s|${transferStepDestinationProtoSpec}|${transferStepDestinationProtoSpec}${destinationUsernamePortion}|" )
		fi

		#  this is a direct transfer, so we can just use the transfer list unchanged
		local _tmpTransferId=$( listTransfer/getTransferIdForTransferList "$_tempTransferList" )
		
		#  if this transferStep was already finished,
		if [[ -e "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.finished" ]]; then
			#  ...just return "4" (SKIP_TRANSFER_STEP),
			return 4
		else
			if [[ -e "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.dumpfile" && \
			      ! -s "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.dumpfile" ]]; then
				rm -f "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.dumpfile"
			fi
			# ...if not, rename temporary copy
			mv "$_tempTransferList" "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.transferList"

			local tgftpTransferCommand=$( listTransfer/createTgftpTransferCommand \
						      "${transferStepSource}${sourcePath}${sourceFile}" \
						      "${transferStepDestination}${destinationPath}${destinationFile}" \
						      "$transferStepDefaultParams" \
						      "$tgftpLogfileName" \
						      "$_tmpTransferId" \
						      "0" \
						      "0" \
						      "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.transferList" \
						      "" )

			#simulateTransfer

			if [[ $? != 0 ]]; then
				echo -e "\n${_program} [${gtInstance}]: tgftp transfer command couldn't be created!" 1>&2
				exit $_gtransfer_exit_software
			fi

			helperFunctions/echoIfVerbose -e "\n${_program} [${gtInstance}]: tgftp transfer command:\n$( helperFunctions/catIfVerbose "$tgftpTransferCommand" )"

			bash $tgftpTransferCommand &>"${tgftpTransferCommand}Output" &
			#true &
		fi

	#  initial transfer step of a multi-step transfer (source to transit site)
	#
	#  The initial transfer step can be detected as follows:
	#+ The source portion has no path added to the URL.
	elif [[ "$transferStepSource" == "$( helperFunctions/getURLWithoutPath $transferStepSource )" ]]; then
		#  handle usernames in URLs
		transferStepSourceProtoSpec=$( helperFunctions/getProtocolSpecifier $transferStepSource )
		#  replace protocol spec with proto. spec and username (don't forget "@" at the end)
		#  NOTICE:
		#+ Please be aware of the fact, that the shell expands the variables in the sed scripts before actually running the sed scripts.
		#+ As the proto. spec contains "/"es. they must be either escaped (hard!) or one just changes the "/"es of the "s///" command to
		#+ "|"s, as done in the following.
		transferStepSource=$( echo $transferStepSource | sed -e "s|${transferStepSourceProtoSpec}|${transferStepSourceProtoSpec}${sourceUsernamePortion}|" )

		#  source can stay as it is (the username portion is contained in
		#+ the transfer list), destination needs to be changed
		sed -e "s|$_destinationWithoutPath|${transferStepDestination}/${transitSiteTempDir}/|g" -i "$_tempTransferList"

		local _tmpTransferId=$( listTransfer/getTransferIdForTransferList "$_tempTransferList" )
		
		#  if this transferStep was already finished,
		if [[ -e "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.finished" ]]; then
			#  ...just return "4" (SKIP_TRANSFER_STEP),
			return 4
		else
			if [[ -e "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.dumpfile" && \
			      ! -s "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.dumpfile" ]]; then
				rm -f "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.dumpfile"
			fi
			# ...if not, rename temporary copy
			mv "$_tempTransferList" "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.transferList"

			local tgftpTransferCommand=$( listTransfer/createTgftpTransferCommand \
						      "${transferStepSource}${sourcePath}${sourceFile}" \
						      "${transferStepDestination}${transitSiteTempDir}/" \
						      "$transferStepDefaultParams" \
						      "$tgftpLogfileName" \
						      "$_tmpTransferId" \
						      "0" \
						      "1" \
						      "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.transferList" \
						      "${transferStepDestination}${transitSiteTempDir}/" )
		
			#simulateTransfer
			#simulateError

			if [[ $? != 0 ]]; then
				echo -e "\n${_program} [${gtInstance}]: tgftp transfer command couldn't be created!" 1>&2
				exit $_gtransfer_exit_software
			fi

			helperFunctions/echoIfVerbose -e "\n${_program} [${gtInstance}]: tgftp transfer command:\n$( helperFunctions/catIfVerbose "$tgftpTransferCommand" )"

			bash $tgftpTransferCommand &>"${tgftpTransferCommand}Output" &
			#true &
		fi

	#  transfer (transit site to transit site)
	#
	#  A transfer from transit site to transit site can be
	#+ detected as follows:
	#+ A transit address has a temp path added to the URL
	#+ and therefore should differ from the string printed
	#+ by getURLWithoutPath().
	#
	#  TODO:
	#+ Perhaps it would be better to check for both requirements (source and
	#+ destination are transit sites)
	elif [[ "$transferStepDestination" != "$( helperFunctions/getURLWithoutPath $transferStepDestination )" ]]; then
		#  source and destination needs to be changed to the transit
		#+ sites URLs with path
		sed -e "s|${_sourceWithoutPath}|${transferStepSource}/${transitSiteTempDir}/|g" \
		    -e "s|${_destinationWithoutPath}|${transferStepDestination}/${transitSiteTempDir}/|g" \
		    -i "$_tempTransferList"

		local _tmpTransferId=$( listTransfer/getTransferIdForTransferList "$_tempTransferList" )
		
		#  if this transferStep was already finished,
		if [[ -e "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.finished" ]]; then
			#  ...just return "4" (SKIP_TRANSFER_STEP),
			return 4
		else
			if [[ -e "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.dumpfile" && \
			      ! -s "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.dumpfile" ]]; then
				rm -f "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.dumpfile"
			fi
			# ...if not, rename temporary copy
			mv "$_tempTransferList" "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.transferList"

			local tgftpTransferCommand=$( listTransfer/createTgftpTransferCommand \
						      "${transferStepSource}${transitSiteTempDir}/${sourceFile}" \
						      "${transferStepDestination}${transitSiteTempDir}/" \
						      "$transferStepDefaultParams" \
						      "$tgftpLogfileName" \
						      "$_tmpTransferId" \
						      "1" \
						      "1" \
						      "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.transferList" \
						      "${transferStepDestination}${transitSiteTempDir}/" )

			#simulateTransfer

			if [[ $? != 0 ]]; then
				echo -e "\n${_program} [${gtInstance}]: tgftp transfer command couldn't be created!" 1>&2
				exit $_gtransfer_exit_software
			fi

			helperFunctions/echoIfVerbose -e "\n${_program} [${gtInstance}]: tgftp transfer command:\n$( helperFunctions/catIfVerbose "$tgftpTransferCommand" )"

			bash $tgftpTransferCommand &>${tgftpTransferCommand}Output &
			#true &
		fi

	#  last step (transit site to final destination)
	#
	#  The last step is identified by the transfer step
	#+ target being identical to the target of the data
	#+ path, which itself is identical to the target without
	#+ path portion.
	elif [[ "$transferStepDestination" == "$( helperFunctions/getURLWithoutPath $transferStepDestination )" ]]; then
		#  only source needs to be changed to the transit site URL
		sed -e "s|$_sourceWithoutPath$_sourcePath|${transferStepSource}/${transitSiteTempDir}/${_destinationPath}|g" \
		    -i "$_tempTransferList"

		local _tmpTransferId=$( listTransfer/getTransferIdForTransferList "$_tempTransferList" )

		#  handle usernames in URLs
		transferStepDestinationProtoSpec=$( helperFunctions/getProtocolSpecifier $transferStepDestination )
		#  replace protocol spec with proto. spec and username (don't forget "@" at the end)
		#  NOTICE:
		#+ Please be aware of the fact, that the shell expands the variables in the sed scripts before actually running the sed scripts.
		#+ As the proto. spec contains "/"es. they must be either escaped (hard!) or one just changes the "/"es of the "s///" command to
		#+ "|"s.
		transferStepDestination=$( echo $transferStepDestination | sed -e "s|${transferStepDestinationProtoSpec}|${transferStepDestinationProtoSpec}${destinationUsernamePortion}|" )

		#  if this transferStep was already finished,
		if [[ -e "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.finished" ]]; then

			#  ...just return "4" (SKIP_TRANSFER_STEP),
			return 4
		else
			if [[ -e "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.dumpfile" && \
			      ! -s "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.dumpfile" ]]; then
				rm -f "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.dumpfile"
			fi

			# ...if not, rename temporary copy
			mv "$_tempTransferList" "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.transferList"

			local tgftpTransferCommand=$( listTransfer/createTgftpTransferCommand \
						      "${transferStepSource}${transitSiteTempDir}/${sourceFile}" \
						      "${transferStepDestination}${destinationPath}${destinationFile}" \
						      "$transferStepDefaultParams" \
						      "$tgftpLogfileName" \
						      "$_tmpTransferId" \
						      "1" \
						      "0" \
						      "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.transferList" \
						      "" )

			#simulateTransfer
			#simulateError

			if [[ $? != 0 ]]; then
				echo -e "\n${_program} [${gtInstance}]: tgftp transfer command couldn't be created!" 1>&2
				exit $_gtransfer_exit_software
			fi

			helperFunctions/echoIfVerbose -e "\n${_program} [${gtInstance}]: tgftp transfer command:\n$( helperFunctions/catIfVerbose "$tgftpTransferCommand" )"

			bash $tgftpTransferCommand &>${tgftpTransferCommand}Output &
			#true &
		fi

	fi

	tgftpTransferCommandPid="$!"

	#  indicate progress
	while kill -0 $tgftpTransferCommandPid &>/dev/null; do
		echo -n "$gtProgressIndicator"
		sleep 2
	done

	helperFunctions/echoIfVerbose ""

	wait $tgftpTransferCommandPid

	local RETURN="$?"

	#  save finished state, just in case another step fails and gtransfer exits
	#+ and is then restarted by the user. This way, finished steps aren't
	#+ repeated. If all steps finish/succeed, the finished state files can be
	#+ removed by gtransfer.
	#
	#  transferId is either the SHA1 hash of source;destination, or the hash of
	#+ the used transfer list.
	if [[ "$RETURN" == "0" ]]; then
		touch "${__GLOBAL__gtTmpDir}/${_tmpTransferId}.finished"
		rm -f "$tgftpTransferCommand" &>/dev/null
		rm -f "${tgftpTransferCommand}Output" &>/dev/null
	elif [[ $RETURN == 130 ]]; then
		:
	else
		#  if transfer step failed print the output of the tgftp command
		cat ${tgftpTransferCommand}Output
	fi

	#echo "Returned $RETURN"

	return $RETURN
}


listTransfer/createTgftpTransferCommand()
{
	#  creates the tgftp transfer command and puts it in a file
	#
	#  usage:
	#+ listTransfer/createTgftpTransferCommand source \
	#+					   destination \
	#+					   gsiftpParams \
	#+					   logfileName \
	#+					   transitSite \
	#+					   transferId \
	#+					   fromTransitSite \
	#+					   toTransitSite \
	#+					   transferList \
	#+					   transitDirUrl

	local source="$1"
	local destination="$2"
	local gsiftpParams="$3"
	local logfileName="$4"
	local transferId="$5"
	#  transfer from transit site? yes (1) / no (0)
	local fromTransitSite="$6"
	#  transfer to transit site? yes (1) / no (0)
	local toTransitSite="$7"
	local _transferList="$8"
	local transitDirUrl="$9"

	#+ To support multiple concurrent transfers, "$tgftpTransferCommand" must be
	#+ a unique name. One could use the transfer id as prefix:
	#+
	#+ 6dd5928ca873099a381e465afecfa9ef22071c8a.$tgftpTransferCommand
	local tgftpTransferCommandSuffix="tgftpTransferCommand"
	local tgftpTransferCommand="${__GLOBAL__gtTmpDir}/$transferId.$tgftpTransferCommandSuffix"

	local tgftpPostCommandParam=""
	local tgftpPostCommand=""

	local gucMaxRetries="${GUC_MAX_RETRIES:-$gucMaxRetries}"

	#  This should create a unique filename correspondent to this specifc tgftp
	#+ command.
	local dumpfileName="${__GLOBAL__gtTmpDir}/${transferId}.dumpfile"

	#  add additional guc parameters
	#
	#  This will enable:
	#+ * restart functionality of guc
	#+ * restart exactly one times
	#+ * create a dumpfile which will contain files that failed to transfer
	#+ * consider 30 seconds without transferred data as stall (meaning: after
	#+   30 secs of time without data transferred, the transfer (of a file) is
	#+   restarted)
	#
	#  NOTICE:
	#+ There is a difference between a dumpfile created by an URL transfer
	#+ and a dumpfile created by a list transfer. A dumpfile created by an
	#+ URL transfer contains the same information as a dumpfile created by
	#+ guc with the "-do|-dump-only" option:
	#+ * source URL
	#+ * destination URL
	#+ * offset
	#+ * size
	#+ * modify timestamp
	#+ * permissions
	#+
	#+ A dumpfile created by a list transfer only contains:
	#+ * source URL
	#+ * destination URL
	#+ * offset

	# Deactivate reliability (GT_NO_RELIABILITY=1) if needed.
	#local addGsiftpParams
	local _gucReliabilityOptions
	if [[ $GT_NO_RELIABILITY -eq 1 ]]; then

		_gucReliabilityOptions=""
	else
		_gucReliabilityOptions="-restart -rst-retries $gucMaxRetries -dumpfile $dumpfileName -stall-timeout 30"
		# Filter "-pp" from "gsiftpParams", as pipelining and reliability don't
		# work well in conjunction.
		#
		# Just remove the "-pp" param, because this will leave two spaces at the
		# position where "-pp" was removed. This way one can detect that a param
		# was removed by gt.
		gsiftpParams=$( echo "$gsiftpParams" | sed -e 's/-pp//' )
	fi

	local _gucSyncOptions="-sync -sync-level 1"

	#  perform recursive transfer
	if [[ $recursiveTransferSet -eq 0 ]]; then
		gsiftpParams="$gsiftpParams -r"
	fi

	# encrypt data channel?
	if [[ $_encryptDataChannelSet -eq 0 ]]; then

		gsiftpParams="$gsiftpParams -dcpriv"

	# checksum data channel?
	elif [[ $_checksumDataChannelSet -eq 0 ]]; then

		gsiftpParams="$gsiftpParams -dcsafe"

	fi


	#  Do this only if uberftp is available!
	if hash uberftp &>/dev/null; then
		#  If a transit site is involved as source, the temporary transit
		#+ directory will be removed after the transfer succeeded.
		if [[ $fromTransitSite -eq 1 ]]; then
			tgftpPostCommandParam="--post-command"
			#  remove the whole temp. transit dir from the transit site
			tgftpPostCommand="uberftp -rm -r $( helperFunctions/getURLWithoutPath $source )$( helperFunctions/getPathFromURL $source ) &"
		fi
		#  workaround a guc limitation: guc by default creates dirs group and
		#+ world r-x. This workaround makes sure, that the transit dir is only accessible
		#+ by the owner (create and chmod happen prior to the transfer).
		#
		#  NOTICE:
		#+ This was tested on Louhi (with GT5.0.3). There needs to be a short
		#+ sleep between dir creation and chmod, as otherwise the chmod fails.
		#+
		#+ $ uberftp -mkdir gsiftp://p6012-deisa.huygens.sara.nl:2812/scratch/shared/prace/gridftp/transitSiteTempDir.rQoM5180 && uberftp -chmod 0700 gsiftp://p6012-deisa.huygens.sara.nl:2812/scratch/shared/prace/gridftp/transitSiteTempDir.rQoM5180
		#+ Failed to connect to 145.100.18.152 port 2812: Cannot assign requested address 
		#+
		#+ $ uberftp -mkdir gsiftp://p6012-deisa.huygens.sara.nl:2812/scratch/shared/prace/gridftp/transitSiteTempDir.rQoM5180 && sleep 0.5 &&  uberftp -chmod 0700 gsiftp://p6012-deisa.huygens.sara.nl:2812/scratch/shared/prace/gridftp/transitSiteTempDir.rQoM5180
		if [[ $toTransitSite -eq 1 ]]; then		     
			#  get FQDN and port number from destination URL
			local _fqdn=$( helperFunctions/getFQDNFromURL "$destination" )
			local _portNumber=$( helperFunctions/getPortNumberFromURL "$destination" )
			local _transitDir=$( helperFunctions/getPathFromURL "$transitDirUrl" )

			tgftpPreCommandParam="--pre-command"
			#tgftpPreCommand="uberftp -mkdir $transitDirUrl && sleep 0.5 && uberftp -chmod 0700 $transitDirUrl"
			#  Alternative to the commands above which works around the issue mentioned above. Which wasn't really
			#+ solved with the short sleep.
			tgftpPreCommand="echo 'mkdir $_transitDir; chmod 0700 $_transitDir; bye' | uberftp -P $_portNumber $_fqdn"
		fi
	fi

	#  always remove dumpfile if it is empty after a transfer. This is
	#+ because otherwise guc complains about an empty dumpfile and does
	#+ not make a transfer using the commandline arguments.
	if [[ ! -z $tgftpPostCommand ]]; then
		tgftpPostCommand="$tgftpPostCommand if [[ ! -s $dumpfileName ]]; then rm $dumpfileName; fi"
	else
		tgftpPostCommandParam="--post-command"
		tgftpPostCommand="if [[ ! -s $dumpfileName ]]; then rm $dumpfileName; fi"
	fi

	########################################################################

	#  new

	#  case
	#  |
	#  |  verbose (0 false, 1 true)
	#  |  |
	#  |  | fromTransitSite (0 false, 1 true)
	#  |  | |
	#  |  | | toTransitSite (0 false, 1 true)
	#  |  | | |
	#
	#  0  0 0 0 source -> dest
	#  1  0 0 1 source -> transit
	#  2  0 1 0 transit -> dest
	#  3  0 1 1 transit -> transit
	#
	#  4  1 0 0 source -> dest
	#  5  1 0 1 source -> transit
	#  6  1 1 0 transit -> dest
	#  7  1 1 1 transit -> transit

	#  case 4
	if [[ $verboseExec -eq 1 && \
	      $fromTransitSite -eq 0 && \
	      $toTransitSite -eq 0 \
	]]; then
		echo "tgftp" \
		     "--log-filename \"$logfileName\"" \
		     "--force-log-overwrite" \
		     "$tgftpPostCommandParam" \"$tgftpPostCommand\" \
		     "-- -dbg $gsiftpParams $_gucReliabilityOptions $_gucSyncOptions -f $_transferList" > "$tgftpTransferCommand"

	#  case 5
	elif [[ $verboseExec -eq 1 && \
		$fromTransitSite -eq 0 && \
		$toTransitSite -eq 1 \
	]]; then
		echo "tgftp" \
		     "--log-filename \"$logfileName\"" \
		     "--force-log-overwrite" \
		     "$tgftpPreCommandParam" \"$tgftpPreCommand\" \
		     "$tgftpPostCommandParam" \"$tgftpPostCommand\" \
		     "-- -dbg $gsiftpParams $_gucReliabilityOptions $_gucSyncOptions -f $_transferList" > "$tgftpTransferCommand"

	#  case 7
	elif [[ $verboseExec -eq 1 && \
		$fromTransitSite -eq 1 && \
		$toTransitSite -eq 1 \
	]]; then
		echo "tgftp" \
		     "--log-filename \"$logfileName\"" \
		     "--force-log-overwrite" \
		     "$tgftpPreCommandParam" \"$tgftpPreCommand\" \
		     "$tgftpPostCommandParam" \"$tgftpPostCommand\" \
		     "-- -dbg $gsiftpParams $_gucReliabilityOptions $_gucSyncOptions -f $_transferList" > "$tgftpTransferCommand"

	#  case 6
	elif [[ $verboseExec -eq 1 && \
		$fromTransitSite -eq 1 && \
		$toTransitSite -eq 0 \
	]]; then
		echo "tgftp" \
		     "--log-filename \"$logfileName\"" \
		     "--force-log-overwrite" \
		     "$tgftpPostCommandParam" \"$tgftpPostCommand\" \
		     "-- -dbg $gsiftpParams $_gucReliabilityOptions $_gucSyncOptions -f $_transferList" > "$tgftpTransferCommand"

	#  case 0
	elif [[ $verboseExec -eq 0 && \
		$fromTransitSite -eq 0 && \
		$toTransitSite -eq 0 \
	]]; then
		echo "tgftp" \
		     "--log-filename \"$logfileName\"" \
		     "--force-log-overwrite" \
		     "$tgftpPostCommandParam" \"$tgftpPostCommand\" \
		     "-- $gsiftpParams $_gucReliabilityOptions $_gucSyncOptions -f $_transferList" > "$tgftpTransferCommand"

	#  case 1
	elif [[ $verboseExec -eq 0 && \
		$fromTransitSite -eq 0 && \
		$toTransitSite -eq 1 \
	]]; then
		echo "tgftp" \
		     "--log-filename \"$logfileName\"" \
		     "--force-log-overwrite" \
		     "$tgftpPreCommandParam" \"$tgftpPreCommand\" \
		     "$tgftpPostCommandParam" \"$tgftpPostCommand\" \
		     "-- $gsiftpParams $_gucReliabilityOptions $_gucSyncOptions -f $_transferList" > "$tgftpTransferCommand"

	#  case 3
	elif [[ $verboseExec -eq 0 && \
		$fromTransitSite -eq 1 && \
		$toTransitSite -eq 1 \
	]]; then
		echo "tgftp" \
		     "--log-filename \"$logfileName\"" \
		     "--force-log-overwrite" \
		     "$tgftpPreCommandParam" \"$tgftpPreCommand\" \
		     "$tgftpPostCommandParam" \"$tgftpPostCommand\" \
		     "-- $gsiftpParams $_gucReliabilityOptions $_gucSyncOptions -f $_transferList" > "$tgftpTransferCommand"

	#  case 2
	elif [[ $verboseExec -eq 0 && \
		$fromTransitSite -eq 1 && \
		$toTransitSite -eq 0 \
	]]; then
		echo "tgftp" \
		     "--log-filename \"$logfileName\"" \
		     "--force-log-overwrite" \
		     "$tgftpPostCommandParam" \"$tgftpPostCommand\" \
		     "-- $gsiftpParams $_gucReliabilityOptions $_gucSyncOptions -f $_transferList" > "$tgftpTransferCommand"

	fi

	########################################################################

	if [[ $? -eq 0 ]]; then
		echo "$tgftpTransferCommand"
		return 0
	else
		return 1
	fi
}


listTransfer/createTransferList() {
	# create transfer list from source and destination URLs
	#
	# usage:
	# listTransfer/createTransferList gsiftpSourceUrl gsiftpDestinationUrl
	#
	# prints the transfer list filename to stdout
	#
	# returns:
	# 0 if everything is allright
	# 1 otherwise

	local _source="$1"
	local _destination="$2"
	
	local _transferListFile="${__GLOBAL__gtTmpDir}/$$_transferList.$__GLOBAL__gtTmpSuffix"

	# Check if valid URLs are provided
	if ! helperFunctions/isValidUrl $_source; then
		echo -e "\n${_program} [${gtInstance}]: \"$_source\" invalid source URL (check FQDN or protocol part)!" 1>&2
		return 1
	elif ! helperFunctions/isValidUrl $_destination; then
		echo -e "\n${_program} [${gtInstance}]: \"$_destination\" invalid destination URL (check FQDN or protocol part)!" 1>&2
		return 1
	# check if target URL is a "http://" URL
	elif [[ "$( helperFunctions/getProtocolSpecifier $_destination )" == "http://" || \
		"$( helperFunctions/getProtocolSpecifier $_destination )" == "https://" \
	]]; then
		echo -e "\n${_program} [${gtInstance}]: Target URL cannot be a \"http[s]://\" URL!" 1>&2
		return 1
	fi
	
	# perform recursive transfer
	if [[ $recursiveTransferSet -eq 0 ]]; then
		local _recursive="-r"
	else
		local _recursive=""
	fi
	
	# to get the transfer list we use guc with "-do" option
	globus-url-copy -do "$_transferListFile" $_recursive "$_source" "$_destination"

	if [[ "$?" == "0" && -e "$_transferListFile" ]]; then
		# strip comment lines
		#sed -i -e '/^#.*$/d' "$_transferListFile"
		# Reverted, as this breaks the multi-step functionality, because if an empty dir is included in the transfer
		# but not created on the transit site(s), the transfer lists for the second step and following steps
		# will contain a reference to a non-existing directory on the source side (which is a transit site during
		# these steps).
		# Uncomment directory lines (the URLs there end with a `/`!), so that at least dirs containing
		# other empty dirs are created on the destination side
		#sed -e '/^#\".*\/\" \".*\/\" .*/s/^#//g' -i "$_transferListFile"

		# Now check if the transfer list only has one line (i.e. only
		# one file should be transferred). If this is the case, the
		# transfer list does not contain the size of the file. This is
		# a bug in guc that is still existing in version 9.11. The
		# Globus JIRA ticket is at `https://globus.atlassian.net/browse/GT-318`
		# and also it is stated there that this bug is fixed, I still
		# run into it when trying to transfer one file only.

		if [[ $( wc -l "$_transferListFile" | cut -d ' ' -f 1) == "1" ]]; then

			local _file=""
			local _fileSize=0

			# If there's only one line in the transfer list, we need to add
			# the missing file size information manually, e.g. with uberftp or stat for
			# local files.
			if [[ $( helperFunctions/getURLWithoutPath "$_source" ) == "file://" ]]; then

				local _filePath=$( helperFunctions/getPathFromURL "$_source" )
				local _fileName=$( helperFunctions/getFilenameFromURL "$_source" )

				# Anticipate the case where all files in a dir should be transferred
				# but only one file exists in dir. If URL ends on '/', $_fileName would
				# be empty. Hence use '*' and don't use double quotes in the stat call
				# so the '*' is expanded to the one file in the dir.
				if [[ "$_fileName" == "" ]]; then

					_fileName="*"
				fi

				_file="${_filePath}${_fileName}"
				_file=$( helperFunctions/urlDecode "$_file" )

				_fileSize=$( stat -c %s $_file )

			else
				_fileSize=$( uberftp -size "$_source" )
			fi

			# remove newline from end of file
			truncate -s -1 "$_transferListFile"

			# add size
			echo " 0,-1 size=$_fileSize;" >> "$_transferListFile"
		fi

		echo "$_transferListFile"
		return 0
	else
		return 1
	fi
}


listTransfer/getDestinationFromTransferList() {
	#  gets the complete destination URL from a transfer list
	#
	#  usage:
	#+ listTransfer/getDestinationFromTransferList transferList

	local _transferList="$1"

	#  format of transfer list (guc v8.2):
	#													 offset
	#  source					      destination					 |    size, modify timestamp and permissions
	#  |						      |						         |    |
	#  "ftp://vserver1.asc:2811/~/files/test4/file.00355" "ftp://vserver2.asc:2811/~/files/test4/file.00355" 0,-1 size=0;modify=1328981550;mode=0644;

	#  we require that all URLs in a transfer list have the same source and
	#+ destination hosts, hence we just pick the first line and extract the
	#+ destination
	local _destination=$( head -1 "$_transferList" | cut -d ' ' -f 2 | sed -e 's/"//g' -e 's/^#//g')

	if [[ "$?" == "0" ]]; then
		echo "$_destination"
		return 0
	else
		return 1
	fi
}


listTransfer/getSourceFromTransferList() {
	#  gets the complete source URL from a transfer list
	#
	#  usage:
	#+ listTransfer/getSourceFromTransferList transferList

	local _transferList="$1"

	#  format of transfer list (guc v8.2):
	#													offset
	#  source					     destination					|    size, modify timestamp and permissions
	#  |						  |						  |    |
	#  "ftp://vserver1.asc:2811/~/files/test4/file.00355" "ftp://vserver2.asc:2811/~/files/test4/file.00355" 0,-1 size=0;modify=1328981550;mode=0644;

	#  we require that all URLs in a transfer list have the same source and
	#+ destination hosts, hence we just pick the first line and extract the
	#+ source
	local _source=$( head -1 "$_transferList" | cut -d ' ' -f 1 | sed -e 's/"//g' -e 's/^#//g')

	if [[ "$?" == "0" ]]; then
		echo "$_source"
		return 0
	else
		return 1
	fi
}


listTransfer/getTransferIdForTransferList() {
	#  get the transfer id for the given transfer list
	#
	#  usage:
	#+ listTransfer/getTransferIdForTransferList transferList

	local _transferList="$1"

	local _transferId=$( sha1sum "$_transferList" | cut -d ' ' -f 1 )

	if [[ "$?" == "0" ]]; then
		echo "$_transferId"
		return 0
	else
		return 1
	fi
}


listTransfer/getTransferSizeFromTransferList() {
	# gets the complete size of all data transferred with the provided
	# transfer list, but does not count the size of directories, because
	# guc does not store a size datum for directories in transfer lists.
	#
	# usage:
	# listTransfer/getTransferSizeFromTransferList transferList
	
	local _transferList="$1"

	local _sum=0

	# format of transfer list (guc v8.2):
	#                                                                                                       offset
	# source                                             destination                                        |    size, modify timestamp and permissions
	# |						     |                                                  |    |
	# "ftp://vserver1.asc:2811/~/files/test4/file.00355" "ftp://vserver2.asc:2811/~/files/test4/file.00355" 0,-1 size=0;modify=1328981550;mode=0644;

	# get all file sizes of the transfer list, one each line, but:
	# * ignore lines starting with `#`
	# * ignore lines not containing a `size=` string
	local _fileSizes=$( grep -v '^#' "$_transferList" | grep 'size=' | cut -d ' ' -f 4 | cut -d ';' -f 1 | cut -d '=' -f 2 )

	# now sum up all file sizes
	for _size in $( echo $_fileSizes ); do
		_sum=$(( $_sum + $_size ))
		if [[ "$?" != "0" ]]; then
			break
		fi
	done

	if [[ "$?" == "0" ]]; then
		echo "$_sum"
		return 0
	else
		return 1
	fi
}


listTransfer/getNumberOfFilesFromTransferList()
{
	#  gets the number if files from the given transfer list (assuming that
	#+ each line counts for one file)
	
	local _transferList="$1"
	
	local _numberOfFiles=$( wc -l <"$_transferList" )
	
	if [[ $? -eq 0 ]]; then
		echo "$_numberOfFiles"
		return 0
	else
		return 1
	fi
}

